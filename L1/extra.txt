1. Какой самый эффективный способ конкатенации строк?

Через функцию copy
strings := []string{"This ", "is ", "even ",
		"more ", "performant "}
 
	bs := make([]byte, 100)
	bl := 0
 
	for _, val := range strings {
		bl += copy(bs[bl:], []byte(val))
	}
 
	fmt.Println(string(bs[:]))


2. Что такое интерфейсы, как они применяются в Go?


Структуры описывают данные, интерфейсы описывают поведение. Они определяет и описывает конкретные методы, которые должны быть у какого-то другого типа.

Уменьшение количества шаблонного кода
func (c *Customer) WriteJSON(w io.Writer) error {
    js, err := json.Marshal(c)
    if err != nil {
        return err
    }

    _, err = w.Write(js)
    return err
}


Модульное тестирование и заглушки
Архитектура приложения


3.Чем отличаются RWMutex от Mutex?
Перед чтением защищаемого объекта делается .RLock() и только вызовы .Lock() в других горутинах блокируются, вызовы .RLock() спокойно проходят. 
Когда отпускаете мьютекс через .RUnlock(), ждущие вызовы .Lock() по-очереди могут забирать мьютекс на себя.

Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.

4.Чем отличаются буферизированные и не буферизированные каналы?

По умолчанию каналы не буферизованы, это означает, что они будут принимать отправления (chan <-), только если есть соответствующий прием (<- chan), 
готовый принять отправленное значение.
 Буферизованные каналы принимают ограниченное количество значений без соответствующего приемника для этих значений.

5.Какой размер у структуры struct{}{}?

 она занимает 0 байт, если выводить простым способом размер переменнов

 package main

import (
	"fmt"
	"unsafe"
)
type t1 struct {
	f int
}
type t2 struct {
	f int
	g struct{}
}
func main() {
	fmt.Println(unsafe.Sizeof(t1{}), unsafe.Sizeof(t2{})) //8 16
}

Это не очень удобно для массивов или срезов. Но это полезно для карт. Карта без значений похожа на набор. Вы можете вставлять ключи и проверять, присутствуют ли они.
 Отсутствие значения, как вы обнаружили, экономит место.

 6. Есть ли в Go перегрузка методов или операторов?
 В Go нет перегрузки методов и функций. Предлагается просто давать разные имена методам и функциям.

7. В какой последовательности будут выведены элементы map[int]int?
 по порядку ключа
Пример:
m[0]=1
m[1]=124
m[2]=281

8.В чем разница make и new?

Встроенная функция new выделяет память (создает неименованную переменную и возваращет указатель на ее значение)
‘make’ имеет вариадический аргумент ‘size’.
‘make’ выделяет память и инциализирует только объекты типов: slice, map, or chan.
‘new’ возвращает указатель вместо значения возвращаемое функцией ‘make’.

9.Сколько существует способов задать переменную типа slice или map?

var a []int
var b []int = []int{1, 2, 3}
c := []int{1, 2, 3}
d := []int{1: 12}
a := make([]int, 10, 10)

// Второй вариант безопаснее
var m = map[int]int{}
m = someFunc()
fmt.Println(m)
// с помощью встроенной функции make:
m1 := make(map[int]int)

// с помощью использования литерала отображения:
m2 := map[int]int{
    // Пары ключ:значение указываются при необходимости
    12: 2,
    1:  5,
}

10. func update(p *int) {
	b := 2
	p = &b
	//*p = b \\так нужно
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p) \\1
	update(p)
	fmt.Println(*p) \\1
}


11.
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}

от 1 до 4 в разном порядке и ошибку, тк неправильно передали wg в горутины \\wg *sync.WaitGroup


12. func main() {
	n := 0
	if true {
		n := 1
		n++
	}
	fmt.Println(n)
}
 
 0, тк область видимости у n в скобках другая


 13. func someAction(v []int8, b int8) { //[]int8{ //получаем указатель на массив и изменили непосредственно сам массив
	v[0] = 100
	v = append(v, b) //не работает, потому что недостаточно емкости
	fmt.Println(v)
	//return v
}

func main2() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(a, 6)
	//a= someAction(a, 6)
	fmt.Println(a)
}


14.func main() {
	slice := []string{"a", "a"}

	slice = func(slice []string) []string {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
		return slice
	}(slice)
	fmt.Print(slice)
}


Крякнуть уточкой за 30 минут


в чем приемущества: 

Конкурентность — один повар переключается между готовкой разных блюд; 

Важно заметить, что в данном случае вычисления не происходят параллельно по-настоящему.
Планировщик просто выбирает, какая задача может продолжить исполнение в данный момент времени.
Но в результате эффективность такого подхода приближена к эффективности параллелизма

   - Позволяет одновременно выполнять несколько задач на одном процессоре.
   - Улучшает отзывчивость и время отклика приложения.
   - Позволяет эффективно использовать ресурсы процессора в многоядерной системе.

Параллелизм — несколько поваров одновременно готовят блюда, каждый своё.
параллелизм способ обработки множественных запросом одновременно.

   - Позволяет разделить задачу на более мелкие подзадачи и выполнять их одновременно на
   нескольких процессорах или ядрах.
   - Улучшает производительность и сокращает время выполнения задачи.
   - Позволяет эффективно использовать ресурсы вычислительного кластера или распределенной системы.

микросервисных вч-й

   - Позволяют разделить приложение на меньшие, независимые компоненты (микросервисы), 
   каждый из которых выполняет свою специфическую функцию. могут быть использованы разные 
   технологии для каждого отдельного микросервиса.
   - Облегчают масштабирование и обновление приложения.
   - Улучшают управляемость и надежность системы. (Если обнаруживается компонент системы, 
   который вышел из строя, мы можем изолировать его, чтобы остальная часть системы продолжала 
   функционировать.)

асинхронные вч-й

   - Позволяют продолжать выполнение задачи, не ожидая завершения предыдущих операций.
   - Улучшают отзывчивость системы и способствуют более эффективному использованию ресурсов.
   - Часто используются в сетевых приложениях, где требуется обработка большого количества запросов одновременно.

конвеерных вч-й (Идея заключается в параллельном выполнении нескольких инструкций процессора. 
Сложные инструкции процессора представляются в виде последовательности более простых стадий. 
Вместо выполнения инструкций последовательно (ожидания завершения конца одной инструкции и 
перехода к следующей), следующая инструкция может выполняться через несколько стадий выполнения 
первой инструкции. Это позволяет управляющим цепям процессора получать инструкции со скоростью 
самой медленной стадии обработки, но при этом, намного быстрее, чем при выполнении эксклюзивной 
полной обработки каждой инструкции от начала до конца.)
 
   - Позволяют разбить задачи на последовательные этапы и выполнять их параллельно.
   - Улучшают производительность и ускоряют выполнение задачи.
   - Имеют применение в областях, где требуется обработка большого объема данных 
   (например, визуализация или обработка изображений).

последовательного вч-й

   - Простой и понятный подход к выполнению задач.
   - Позволяют гарантировать порядок выполнения операций и обеспечивать надежность системы.
   - Хорошо подходят для небольших задач или задач, где важна точность результатов.

как влияет эффект масштаба на вычисления  (Эффект масштаба - это явление, когда изменение масштаба 

или размера системы приводит к изменениям в ее характеристиках и свойствах. При увеличении
масштаба системы часто происходит улучшение ее эффективности, производительности или других
параметров.)

   - Увеличение масштаба вычислений может требовать распределенного параллельного выполнения 
   или использование вычислительных кластеров для обеспечения нужных вычислительных ресурсов.
   - При масштабировании вычислений необходимо учитывать пропускную способность сети и пропускную 
   способность хранилищ данных, чтобы избежать узких мест.
   - Эффект масштаба также может повысить значимость асинхронных вычислений и конвейерных вычислений 
   для эффективного использования доступных ресурсов.
   - Микросервисные вычисления могут быть более удобными и гибкими при масштабировании, так как 
   позволяют горизонтальное масштабирование отдельных компонентов системы.


переменная созданная в init() глобальная?

    -Переменная, созданная в функции init(), не является глобальной. 
    Она является локальной переменной, ограниченной областью видимости функции init(). 
    Функция init() выполняется автоматически перед выполнением main()


Когда можно, когда нельзя ипользовать глобальные переменные?

    -Глобальные переменные можно использовать, когда необходимо 
    обеспечить доступность переменной из разных функций или пакетов
    Однако, частое использование глобальных переменных может привести к неявной зависимости и усложнить отладку и поддержку кода.

как создать свою область видимости

    Чтобы создать свою область видимости, можно объявить переменную внутри блока кода, 
    такого как функция, цикл или условие. Переменная будет видима только внутри этого блока и 
    недоступна вне его.

func main() {
    if x := 10; x > 5 {
        fmt.Println("x is greater than 5")
    } else {
        fmt.Println("x is less than or equal to 5")
    }
    // Компиляция ошибка: 'x' undefined
    fmt.Println(x)
}

как создать глобальную переменную только для 1 пакета
    
    var myVariable = "Hello, World!" -маленькими буквами


при удалении одних элементов массива и наполнии новыми вы ушли за лимиты памяти 

    В таких случаях рекомендуется использовать слайсы
    array := [5]int{1, 2, 3, 4, 5}
    slice := array[1:4] // Создаем слайс с элементами [2, 3, 4]
    slice = append(slice, i)

была произведена запись в слайс, но она не сохранилась

    Если запись в слайс произошла, но она не сохранилась, возможно, что у вас есть другая переменная,
     которая ссылается на исходный слайс. При модификации слайса создается новый слайс, и старая 
     переменная может остаться неизменной.

 slice := []int{1, 2, 3, 4, 5}

    // Пытаемся изменить элементы слайса через другую переменную
    otherSlice := slice
    otherSlice[0] = 0

    fmt.Println("Исходный слайс:", slice) // Вывод: [1 2 3 4 5]
    fmt.Println("Другой слайс:", otherSlice) // Вывод: [0 2 3 4 5]

после отработки программы данные в файл записались не полностью 

    Если данные в файл записались не полностью, возможно, не все данные были сохранены или не 
    были закрыты каналы записи файла. Важно вызвать метод Close() для закрытия файла после записи, 
    чтобы убедиться, что все данные будут сохранены.

    func main() {
    data := []byte("Some data to write to file")

    err := ioutil.WriteFile("file.txt", data, 0644)
    if err != nil {
    fmt.Println("Error writing file:", err)
     return
    }
    // Забыли вызвать Close()
    }



после выполнения функции данные исчезают

     вы используете локальные переменные или передаете аргументы в функцию по значению, вместо передачи по ссылке
    func modifySlice(slice []int) {
    slice = append(slice, 4, 5, 6)
    }
    В этом случае, функция modifySlice получает копию ссылки на слайс, и изменения, сделанные внутри функции, не влияют на оригинальный слайс.
    func main() {
    slice := []int{1, 2, 3}

    modifySlice(slice)
    fmt.Println("Исходный слайс:", slice) // Вывод: [1 2 3]
    }

Данные записываются

    func main() {
    // Создаем массив и наполняем данными
    var array [3]string
    array[0] = "Hello"
    array[1] = "World"
    array[2] = "!"

    // Создаем слайс и наполняем данными
    slice := []int{1, 2, 3, 4, 5}

    fmt.Println("Массив:", array) // Вывод: [Hello World !]
    fmt.Println("Слайс:", slice) // Вывод: [1 2 3 4 5]
    }



Данные не записываются, но удаляются 

    Если данные не записываются, но удаляются, возможно, вы работаете с пустым слайсом или массивом, или используете метод copy() для копирования данных в пустой слайс.

    func main() {
    // Удаляем элементы из слайса
    slice := []int{1, 2, 3, 4, 5}
    slice = slice[:0] // Очищаем слайс
    fmt.Println("Слайс после удаления:", slice) // Вывод: []

    // Копирование данных в пустой слайс
    source := []int{1, 2, 3, 4, 5}
    emptySlice := []int{}
    copy(emptySlice, source) // Копирование данных в пустой слайс
    fmt.Println("Пустой слайс после копирования:", emptySlice) // Вывод: []
    }






как гарантировать скорость вч-й 

    Для гарантированной скорости выполнения кода в Go можно использовать горутины (goroutines) и каналы (channels).

как гарантировать синхронность вч-й 

    Для гарантированной синхронности выполнения кода можно использовать мьютексы (mutex), WaitGroup и другие средства синхронизации, предоставляемые пакетом sync в Go.

как гарантировать параллельность вч-й

    В Go параллельность выполнения кода достигается путем запуска нескольких горутин, которые выполняются одновременно
    func main() {
    wg.Add(2)
    go printMessage("Hello")
    go printMessage("World")
    wg.Wait() // Ожидаем выполнения всех горутин
    }

как гарантировать безопасность данных

    В Go безопасность данных достигается путем использования мьютексов (mutex) и других примитивов синхронизации. Мьютексы обеспечивают эксклюзивный доступ к разделяемым данным, 
    что позволяет избежать состояния гонки (race conditions).
    func incrementCounter() {
    mutex.Lock() // Блокируем доступ к общей переменной counter
    counter++
    mutex.Unlock() // Разблокируем доступ
    wg.Done()
    }

как гарантировать отказоустойчивость

    Для гарантированной отказоустойчивости в Go можно использовать механизм восстановления после ошибок (error recovery). Этот механизм позволяет перехватить панику (panic) и 
    выполнить необходимые действия для восстановления из состояния ошибки.

    func recoverFromPanic() {
    if r := recover(); r != nil {
    fmt.Println("Восстановлено от паники:", r)
    }
    }

    func main() {
    defer recoverFromPanic() // Обработка паники внутри функции main
    panic("Что-то пошло не так!") // Вызываем панику
    fmt.Println("Этот код никогда не выполнится") // Этот код не будет выполнен из-за паники
    }   


как реализовать FIFO циклом

    queue := []string{"A", "B", "C"}
    for len(queue) > 0 {
        fmt.Print(queue[0]) // Первый элемент
        queue = queue[1:]   // Удаление из очереди
    }

как итерироваться в for по функции

    В Go можно итерироваться по функции, используя цикл for range

    func main() {
    numbers := getNumbers()
    for _, num := range numbers {
    fmt.Println(num)
    }
    }

    func getNumbers() []int {
    return []int{1, 2, 3, 4, 5}
    }

в чем особенность области видимости цикла for

    Область видимости переменных, объявленных в условии цикла for, ограничена самим циклом. Это означает, что переменные, объявленные в условии цикла, 
    не будут доступны вне этого цикла.


как выйти из бесконечного цикла без break

    можете использовать оператор return или panic, в зависимости от ситуации и требований вашей программы.
    func main() {
    for {
    if условие {
    return // Выход из цикла
    }
    }
    }

цикл итерирующийся по массиву стал бесконечным циклом

    ожет быть связано с проблемой, связанной с индексом вне границ массива или неправильно заданным условием





panic access

    возникает, когда программа пытается получить доступ к элементу или свойству, которых не существует или недоступно.

    func main() {
     arr := []int{1, 2, 3}
     // panic access, так как индекс 5 выходит за пределы доступного диапазона
     fmt.Println(arr[5])
    }


panic nil pointer

    возникает, когда программа пытается получить доступ к объекту или методу, который является нулевым указателем.

    func main() {
        var ptr *int
        // panic nil pointer, так как пытаемся разыменовать нулевой указатель
        fmt.Println(*ptr)
    }

panic conversion

    возникает, когда происходит некорректное преобразование типов данных.

    func main() {
        var num int = 42
        // panic conversion, так как пытаемся преобразовать числовой тип в строковый
        str := string(num)
     fmt.Println(str)
    }